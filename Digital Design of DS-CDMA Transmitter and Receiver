// ============================================================================
// Final Year Project
// Title : Digital Design of DS-CDMA Transmitter and Receiver (All-in-One)
// Description :
//   - Multi-user DS-CDMA transmitter
//   - Multi-user DS-CDMA receiver using despreading & correlation
//   - FPGA friendly top module (Switches -> Input, LEDs/DAC -> Output)
// ============================================================================

module ds_cdma_all #(
    parameter NUM_USERS = 4,      // Number of users
    parameter PN_LEN    = 7       // Length of PN sequence (LFSR)
)(
    input  wire clk_50,           // 50 MHz FPGA clock
    input  wire reset_btn,        // Active-high reset
    input  wire [NUM_USERS-1:0] sw,   // User data inputs
    output wire [7:0] led,        // LEDs for recovered data
    output wire [15:0] dac_bus    // Composite CDMA signal (optional DAC)
);

    // =========================================================================
    // PN SEQUENCE GENERATION (TRANSMITTER)
    // =========================================================================
    reg  [PN_LEN-1:0] lfsr_tx [0:NUM_USERS-1];
    wire              pn_tx   [0:NUM_USERS-1];
    integer i;

    // Fixed seeds for users
    reg [PN_LEN-1:0] seed_array [0:7];
    initial begin
        seed_array[0] = 7'b1000001;
        seed_array[1] = 7'b1100101;
        seed_array[2] = 7'b1110010;
        seed_array[3] = 7'b1011011;
        seed_array[4] = 7'b0110111;
        seed_array[5] = 7'b0011110;
        seed_array[6] = 7'b0101101;
        seed_array[7] = 7'b1110100;
    end

    // LFSR update logic
    always @(posedge clk_50 or posedge reset_btn) begin
        if (reset_btn) begin
            for (i = 0; i < NUM_USERS; i = i + 1)
                lfsr_tx[i] <= seed_array[i];
        end else begin
            for (i = 0; i < NUM_USERS; i = i + 1)
                lfsr_tx[i] <= {lfsr_tx[i][PN_LEN-2:0],
                               lfsr_tx[i][PN_LEN-1] ^ lfsr_tx[i][2]};
        end
    end

    genvar u;
    generate
        for (u = 0; u < NUM_USERS; u = u + 1) begin : PN_TX
            assign pn_tx[u] = lfsr_tx[u][PN_LEN-1];
        end
    endgenerate

    // =========================================================================
    // TRANSMITTER : SPREADING + BPSK MODULATION
    // =========================================================================
    wire signed [15:0] user_bpsk [0:NUM_USERS-1];

    generate
        for (u = 0; u < NUM_USERS; u = u + 1) begin : TX_MOD
            wire spread_bit;
            assign spread_bit   = sw[u] ^ pn_tx[u];
            assign user_bpsk[u] = (spread_bit) ? 16'sd16 : -16'sd16;
        end
    endgenerate

    // Sum of all users (CDMA composite signal)
    reg signed [15:0] cdma_signal;
    integer j;
    always @(*) begin
        cdma_signal = 0;
        for (j = 0; j < NUM_USERS; j = j + 1)
            cdma_signal = cdma_signal + user_bpsk[j];
    end

    // =========================================================================
    // RECEIVER : PN GENERATION + CORRELATION
    // =========================================================================
    reg  [PN_LEN-1:0] lfsr_rx [0:NUM_USERS-1];
    wire              pn_rx   [0:NUM_USERS-1];

    always @(posedge clk_50 or posedge reset_btn) begin
        if (reset_btn) begin
            for (i = 0; i < NUM_USERS; i = i + 1)
                lfsr_rx[i] <= seed_array[i];
        end else begin
            for (i = 0; i < NUM_USERS; i = i + 1)
                lfsr_rx[i] <= {lfsr_rx[i][PN_LEN-2:0],
                               lfsr_rx[i][PN_LEN-1] ^ lfsr_rx[i][2]};
        end
    end

    generate
        for (u = 0; u < NUM_USERS; u = u + 1) begin : PN_RX
            assign pn_rx[u] = lfsr_rx[u][PN_LEN-1];
        end
    endgenerate

    // Correlator
    reg signed [31:0] accumulator [0:NUM_USERS-1];
    reg [3:0] chip_count;
    reg [NUM_USERS-1:0] recovered_bits;

    always @(posedge clk_50 or posedge reset_btn) begin
        if (reset_btn) begin
            chip_count <= 0;
            for (i = 0; i < NUM_USERS; i = i + 1) begin
                accumulator[i]   <= 0;
                recovered_bits[i] <= 0;
            end
        end else begin
            for (i = 0; i < NUM_USERS; i = i + 1) begin
                accumulator[i] <= accumulator[i] +
                    ((cdma_signal >= 0 ? 1 : -1) *
                     (pn_rx[i] ? 1 : -1));
            end

            chip_count <= chip_count + 1;

            if (chip_count == PN_LEN-1) begin
                for (i = 0; i < NUM_USERS; i = i + 1) begin
                    recovered_bits[i] <= (accumulator[i] > 0);
                    accumulator[i]   <= 0;
                end
                chip_count <= 0;
            end
        end
    end

    // =========================================================================
    // OUTPUT ASSIGNMENTS
    // =========================================================================
    assign led[3:0] = recovered_bits;             // User data
    assign led[7]   = (cdma_signal >= 0);         // Composite sign
    assign led[6:4] = 3'b000;

    // DAC Output (optional visualization)
    assign dac_bus = cdma_signal + 16'sd128;

endmodule
